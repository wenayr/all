"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Test = exports.USALoadEasyFuturesM = exports.GateIoLoadEasySpot = exports.MexcLoadEasyFuturesM = exports.BinanceLoadEasyFuturesM = exports.BinanceLoadEasyFutures = exports.BinanceLoadEasySpot = exports.LoadQuoteBase = void 0;
exports.BinanceSymbolsAllObjNew = BinanceSymbolsAllObjNew;
exports.BinanceSymbolsAllObjNewMargin = BinanceSymbolsAllObjNewMargin;
exports.BinanceSymbolsAllObjNewMarginPlus = BinanceSymbolsAllObjNewMarginPlus;
exports.BinanceSymbolsAllObjNewMarginIsolated = BinanceSymbolsAllObjNewMarginIsolated;
exports.MexcSymbolsAllObjNewMarginIsolated = MexcSymbolsAllObjNewMarginIsolated;
exports.SymbolsdUSASymbolsAllObjNewMarginIsolated = SymbolsdUSASymbolsAllObjNewMarginIsolated;
exports.GateIoSymbolsAllObjNewMarginIsolated = GateIoSymbolsAllObjNewMarginIsolated;
exports.BinanceSymbolsAllFuturesObj2 = BinanceSymbolsAllFuturesObj2;
exports.BinanceSymbolsAllFuturesCoinM = BinanceSymbolsAllFuturesCoinM;
exports.BinanceSocketRealTimeSpotNew = BinanceSocketRealTimeSpotNew;
exports.BinanceSocketKlineAllBase = BinanceSocketKlineAllBase;
exports.BinanceSocketKlineSpotAllNew = BinanceSocketKlineSpotAllNew;
exports.BinanceSocketKlineFAll = BinanceSocketKlineFAll;
exports.BinanceSocketKlineDAll = BinanceSocketKlineDAll;
exports.BinanceSocketSpotAllTurboNew = BinanceSocketSpotAllTurboNew;
exports.BinanceSocketAllBase = BinanceSocketAllBase;
exports.BinanceSocketSpotAllNew = BinanceSocketSpotAllNew;
exports.BinanceSocketFuturesAll = BinanceSocketFuturesAll;
exports.BinanceSocketDCoinMAll = BinanceSocketDCoinMAll;
const LoadBase_1 = require("../LoadBase");
const Time_1 = require("../../Common/Time");
var LoadBase_2 = require("../LoadBase");
Object.defineProperty(exports, "LoadQuoteBase", { enumerable: true, get: function () { return LoadBase_2.LoadQuoteBase; } });
class CLoadBars {
}
function BinanceSymbolsAllObjNew(data) {
    return async function () {
        const post = 'https://api1.binance.com/api/v3/exchangeInfo';
        const result = await (await (data.fetch)(post))?.json();
        const symbols = result.symbols.filter((m) => (m.status == "TRADING") && (data?.quoteAsset ? m.quoteAsset == data.quoteAsset : true));
        return {
            symbols: symbols.map((m) => ({
                name: m.symbol,
                tickSize: m.filters?.[0]?.tickSize,
                minPrice: m.filters?.[1]?.tickSize,
                minStepLot: m.filters?.[0]?.tickSize,
                minQty: m.filters?.[2]?.minQty,
                stepSize: m.stepSize?.[2]?.minQty,
                quoteAsset: m.quoteAsset,
                baseAsset: m.baseAsset
            }))
        };
    };
}
function BinanceSymbolsAllObjNewMargin(data) {
    return async function () {
        const post = 'https://api1.binance.com/api/v3/exchangeInfo';
        const result = await (await (data.fetch)(post))?.json();
        const symbols = result.symbols.filter((m) => (m.status == "TRADING") && (data?.quoteAsset ? m.quoteAsset == data.quoteAsset : true) && !m.permissions.includes('LEVERAGED') && m.isMarginTradingAllowed && m.permissions.includes('MARGIN'));
        return {
            symbols: symbols.map((m) => ({
                name: m.symbol,
                tickSize: m.filters?.[0]?.tickSize,
                minPrice: m.filters?.[1]?.tickSize,
                minStepLot: m.filters?.[0]?.tickSize,
                minQty: m.filters?.[2]?.minQty,
                stepSize: m.stepSize?.[2]?.minQty,
                quoteAsset: m.quoteAsset,
                baseAsset: m.baseAsset
            }))
        };
    };
}
function BinanceSymbolsAllObjNewMarginPlus(data) {
    return async function () {
        const post = 'https://api1.binance.com/api/v3/exchangeInfo';
        const result = await (await (data.fetch)(post))?.json();
        const symbols = result.symbols.filter((m) => (m.status == "TRADING") && (data?.quoteAsset ? m.quoteAsset == data.quoteAsset : true));
        const ttt = new Set;
        const arr = [
            "BNBUSDT", "BTCUSDT", "ETHUSDT", "TRXUSDT", "XRPUSDT", "EOSUSDT", "LINKUSDT", "ONTUSDT", "ADAUSDT", "ETCUSDT", "LTCUSDT", "XLMUSDT", "USDCUSDT", "XMRUSDT", "NEOUSDT", "ATOMUSDT", "DASHUSDT", "ZECUSDT", "MATICUSDT", "BATUSDT", "IOSTUSDT", "VETUSDT", "QTUMUSDT", "IOTAUSDT", "XTZUSDT", "BCHUSDT", "RVNUSDT", "BUSDUSDT", "ZILUSDT", "ONEUSDT", "ANKRUSDT", "TFUELUSDT", "IOTXUSDT", "HBARUSDT", "FTMUSDT", "SXPUSDT", "DOTUSDT", "ALGOUSDT", "THETAUSDT", "COMPUSDT", "KNCUSDT", "OMGUSDT", "KAVAUSDT", "DOGEUSDT", "WAVESUSDT", "SNXUSDT", "CRVUSDT", "SUSHIUSDT", "UNIUSDT", "MANAUSDT", "AVAXUSDT", "NEARUSDT", "FILUSDT", "TRBUSDT", "SRMUSDT", "AAVEUSDT", "SANDUSDT", "CHZUSDT", "COTIUSDT", "FETUSDT", "CHRUSDT", "GRTUSDT", "STPTUSDT", "LRCUSDT", "KSMUSDT", "ROSEUSDT", "REEFUSDT", "STXUSDT", "ENJUSDT", "RUNEUSDT", "SKLUSDT", "OGNUSDT", "EGLDUSDT", "1INCHUSDT", "MDTUSDT", "CAKEUSDT", "SOLUSDT", "LINAUSDT", "SUPERUSDT", "GTCUSDT", "PUNDIXUSDT", "AUDIOUSDT", "BONDUSDT", "SLPUSDT", "POLSUSDT", "PONDUSDT", "TVKUSDT", "DENTUSDT", "FTTUSDT", "ARUSDT", "DYDXUSDT", "UNFIUSDT", "AXSUSDT", "SHIBUSDT", "WINUSDT", "ENSUSDT", "ALICEUSDT", "TLMUSDT", "ICPUSDT", "C98USDT", "FLOWUSDT", "BAKEUSDT", "CHESSUSDT", "GALAUSDT", "HIVEUSDT", "DARUSDT", "IDEXUSDT", "MBOXUSDT", "ANTUSDT", "CLVUSDT", "WAXPUSDT", "BNXUSDT", "KLAYUSDT", "TRIBEUSDT", "MINAUSDT", "RNDRUSDT", "JASMYUSDT", "QUICKUSDT", "LPTUSDT", "AGLDUSDT", "BICOUSDT", "CTXCUSDT", "DUSKUSDT", "HOTUSDT", "SFPUSDT", "YGGUSDT", "FLUXUSDT", "ICXUSDT", "CELOUSDT", "VOXELUSDT", "BETAUSDT", "BLZUSDT", "MTLUSDT", "PEOPLEUSDT", "QNTUSDT", "PYRUSDT", "SUNUSDT", "HNTUSDT", "KEYUSDT", "PAXGUSDT", "RAREUSDT", "WANUSDT", "TWTUSDT", "RADUSDT", "CVCUSDT", "QIUSDT", "GMTUSDT", "APEUSDT", "KDAUSDT", "MBLUSDT", "API3USDT", "CTKUSDT", "NEXOUSDT", "MOBUSDT", "WOOUSDT", "ASTRUSDT", "GALUSDT", "OPUSDT", "ANCUSDT", "REIUSDT", "LEVERUSDT", "LDOUSDT", "FIDAUSDT", "KMDUSDT", "FLMUSDT", "BURGERUSDT", "AUCTIONUSDT", "FIOUSDT", "IMXUSDT", "SPELLUSDT", "STGUSDT", "BELUSDT", "WINGUSDT", "AVAUSDT", "LOKAUSDT", "DEXEUSDT", "LUNCUSDT"
        ];
        arr.forEach(e => ttt.add(e));
        return {
            symbols: symbols.map((m) => ({
                name: m.symbol,
                tickSize: m.filters?.[0]?.tickSize,
                minPrice: m.filters?.[1]?.tickSize,
                minStepLot: m.filters?.[0]?.tickSize,
                minQty: m.filters?.[2]?.minQty,
                stepSize: m.stepSize?.[2]?.minQty,
                quoteAsset: m.quoteAsset,
                baseAsset: m.baseAsset
            })).filter(e => ttt.has(e.name))
        };
    };
}
function BinanceSymbolsAllObjNewMarginIsolated(data) {
    return async function () {
        const post = 'https://api1.binance.com/api/v3/exchangeInfo';
        const result = await (await (data.fetch)(post))?.json();
        const symbols = result.symbols.filter((m) => (m.status == "TRADING") && (data?.quoteAsset ? m.quoteAsset == data.quoteAsset : true));
        const ttt = new Set;
        const arr = [
            "1INCHUSDT", "AAVEUSDT", "ACAUSDT", "ACHUSDT", "ADAUSDT", "AGLDUSDT", "AIONUSDT", "AKROUSDT", "ALCXUSDT", "ALGOUSDT", "ALICEUSDT", "ALPACAUSDT", "ALPHAUSDT", "AMPUSDT", "ANCUSDT", "ANKRUSDT", "ANTUSDT", "APEUSDT", "API3USDT", "ARDRUSDT", "ARPAUSDT", "ARUSDT", "ASTRUSDT", "ATAUSDT", "ATOMUSDT", "AUDIOUSDT", "AUTOUSDT", "AVAUSDT", "AVAXUSDT", "AXSUSDT", "BADGERUSDT", "BAKEUSDT", "BALUSDT", "BANDUSDT", "BATUSDT", "BCHUSDT", "BEAMUSDT", "BELUSDT", "BETAUSDT", "BICOUSDT", "BLZUSDT", "BNBUSDT", "BNTUSDT", "BNXUSDT", "BONDUSDT", "BSWUSDT", "BTCSTUSDT", "BTCUSDT", "BTGUSDT", "BTSUSDT", "BTTCUSDT", "BURGERUSDT", "BUSDUSDT", "C98USDT", "CAKEUSDT", "CELOUSDT", "CELRUSDT", "CFXUSDT", "CHESSUSDT", "CHRUSDT", "CHZUSDT", "CKBUSDT", "CLVUSDT", "COCOSUSDT", "COMPUSDT", "COSUSDT", "COTIUSDT", "CRVUSDT", "CTKUSDT", "CTSIUSDT", "CTXCUSDT", "CVCUSDT", "CVPUSDT", "CVXUSDT", "DARUSDT", "DASHUSDT", "DATAUSDT", "DCRUSDT", "DEGOUSDT", "DENTUSDT", "DEXEUSDT", "DGBUSDT", "DIAUSDT", "DNTUSDT", "DOCKUSDT", "DODOUSDT", "DOGEUSDT", "DOTUSDT", "DREPUSDT", "DUSKUSDT", "DYDXUSDT", "EGLDUSDT", "ELFUSDT", "ENJUSDT", "ENSUSDT", "EOSUSDT", "EPXUSDT", "ERNUSDT", "ETCUSDT", "ETHUSDT", "FARMUSDT", "FETUSDT", "FIDAUSDT", "FILUSDT", "FIOUSDT", "FIROUSDT", "FISUSDT", "FLMUSDT", "FLOWUSDT", "FLUXUSDT", "FORTHUSDT", "FORUSDT", "FTMUSDT", "FTTUSDT", "FUNUSDT", "FXSUSDT", "GALAUSDT", "GALUSDT", "GLMRUSDT", "GMTUSDT", "GNOUSDT", "GRTUSDT", "GTCUSDT", "GTOUSDT", "HARDUSDT", "HBARUSDT", "HIGHUSDT", "HIVEUSDT", "HNTUSDT", "HOTUSDT", "ICPUSDT", "ICXUSDT", "IDEXUSDT", "ILVUSDT", "IMXUSDT", "INJUSDT", "IOSTUSDT", "IOTAUSDT", "IOTXUSDT", "IRISUSDT", "JASMYUSDT", "JOEUSDT", "JSTUSDT", "KAVAUSDT", "KDAUSDT", "KEYUSDT", "KLAYUSDT", "KMDUSDT", "KNCUSDT", "KP3RUSDT", "KSMUSDT", "LDOUSDT", "LEVERUSDT", "LINAUSDT", "LINKUSDT", "LITUSDT", "LOKAUSDT", "LPTUSDT", "LRCUSDT", "LSKUSDT", "LTCUSDT", "LTOUSDT", "LUNAUSDT", "LUNCUSDT", "MANAUSDT", "MASKUSDT", "MATICUSDT", "MBLUSDT", "MBOXUSDT", "MCUSDT", "MDTUSDT", "MDXUSDT", "MFTUSDT", "MINAUSDT", "MITHUSDT", "MKRUSDT", "MLNUSDT", "MOBUSDT", "MOVRUSDT", "MTLUSDT", "NBSUSDT", "NEARUSDT", "NEOUSDT", "NEXOUSDT", "NKNUSDT", "NMRUSDT", "NULSUSDT", "OCEANUSDT", "OGNUSDT", "OGUSDT", "OMGUSDT", "OMUSDT", "ONEUSDT", "ONGUSDT", "ONTUSDT", "OOKIUSDT", "OPUSDT", "ORNUSDT", "OXTUSDT", "PAXGUSDT", "PEOPLEUSDT", "PERLUSDT", "PERPUSDT", "PHAUSDT", "PLAUSDT", "PNTUSDT", "POLSUSDT", "POLYUSDT", "PONDUSDT", "POWRUSDT", "PUNDIXUSDT", "PYRUSDT", "QIUSDT", "QNTUSDT", "QTUMUSDT", "QUICKUSDT", "RADUSDT", "RAREUSDT", "RAYUSDT", "REEFUSDT", "REIUSDT", "RENUSDT", "REPUSDT", "REQUSDT", "RLCUSDT", "RNDRUSDT", "ROSEUSDT", "RSRUSDT", "RUNEUSDT", "RVNUSDT", "SANDUSDT", "SCRTUSDT", "SCUSDT", "SFPUSDT", "SHIBUSDT", "SKLUSDT", "SLPUSDT", "SNXUSDT", "SOLUSDT", "SPELLUSDT", "SRMUSDT", "STGUSDT", "STMXUSDT", "STORJUSDT", "STPTUSDT", "STRAXUSDT", "STXUSDT", "SUNUSDT", "SUPERUSDT", "SUSHIUSDT", "SXPUSDT", "SYSUSDT", "TCTUSDT", "TFUELUSDT", "THETAUSDT", "TKOUSDT", "TLMUSDT", "TOMOUSDT", "TORNUSDT", "TRBUSDT", "TRIBEUSDT", "TROYUSDT", "TRUUSDT", "TRXUSDT", "TUSDT", "TUSDUSDT", "TVKUSDT", "TWTUSDT", "UMAUSDT", "UNFIUSDT", "UNIUSDT", "USDCUSDT", "UTKUSDT", "VETUSDT", "VGXUSDT", "VIDTUSDT", "VITEUSDT", "VOXELUSDT", "VTHOUSDT", "WANUSDT", "WAVESUSDT", "WAXPUSDT", "WINGUSDT", "WINUSDT", "WNXMUSDT", "WOOUSDT", "WRXUSDT", "WTCUSDT", "XECUSDT", "XEMUSDT", "XLMUSDT", "XMRUSDT", "XRPUSDT", "XTZUSDT", "XVSUSDT", "YFIIUSDT", "YFIUSDT", "YGGUSDT", "ZECUSDT", "ZENUSDT", "ZILUSDT", "ZRXUSDT"
        ];
        arr.forEach(e => ttt.add(e));
        return {
            symbols: symbols.map((m) => ({
                name: m.symbol,
                tickSize: m.filters?.[0]?.tickSize,
                minPrice: m.filters?.[1]?.tickSize,
                minStepLot: m.filters?.[0]?.tickSize,
                minQty: m.filters?.[2]?.minQty,
                stepSize: m.stepSize?.[2]?.minQty,
                quoteAsset: m.quoteAsset,
                baseAsset: m.baseAsset
            })).filter(e => ttt.has(e.name))
        };
    };
}
function MexcSymbolsAllObjNewMarginIsolated(data) {
    return async function () {
        const post = 'https://api.mexc.com/api/v3/exchangeInfo';
        const result = await (await (data.fetch)(post))?.json();
        const symbols = result.symbols.filter((m) => (m.status == "ENABLED"));
        return {
            symbols: symbols.map((m) => ({
                name: m.symbol,
                tickSize: m.filters?.[0]?.tickSize,
                minPrice: m.filters?.[1]?.tickSize,
                minStepLot: m.filters?.[0]?.tickSize,
                minQty: m.filters?.[2]?.minQty,
                stepSize: m.stepSize?.[2]?.minQty,
                quoteAsset: m.quoteAsset,
                baseAsset: m.baseAsset
            }))
        };
    };
}
function SymbolsdUSASymbolsAllObjNewMarginIsolated(data) {
    return async function () {
        const post = 'http://localhost:3013/historyUSA/symbols';
        const result = await (await (data.fetch)(post))?.json();
        const symbols = result.result;
        return {
            symbols: symbols.map((m) => ({
                name: m.symbol,
                tickSize: 0.01,
                minPrice: 0.01,
                minStepLot: 0.01,
                minQty: 0.01,
                stepSize: 0.01,
                quoteAsset: "USDT",
                baseAsset: m.symbol
            }))
        };
    };
}
function GateIoSymbolsAllObjNewMarginIsolated(data) {
    return async function () {
        const post = 'https://api.gateio.ws/api/v4/margin/currency_pairs';
        const result = await (await (data.fetch)(post))?.json();
        const symbols = result.filter((m) => (m.status == 1));
        return {
            symbols: symbols.map((m) => ({
                name: m.id,
                tickSize: 0.0001,
                minPrice: 0.0001,
                minStepLot: 0.0001,
                minQty: 0.0001,
                stepSize: 0.0001,
                quoteAsset: m.quote,
                baseAsset: m.base
            }))
        };
    };
}
function BinanceSymbolsAllFuturesObj2(data) {
    return async function () {
        const post = 'https://fapi.binance.com/fapi/v1/exchangeInfo';
        const result = await (await (data.fetch)(post))?.json();
        const symbols = result.symbols.filter((m) => (m.status == "TRADING") && (data?.quoteAsset ? m.quoteAsset == data.quoteAsset : true));
        return {
            symbols: symbols.map((m) => ({
                name: m.symbol,
                tickSize: m.filters?.[0]?.tickSize,
                minPrice: m.filters?.[1]?.tickSize,
                minStepLot: m.filters?.[0]?.tickSize,
                minQty: m.filters?.[2]?.minQty,
                stepSize: m.stepSize?.[2]?.minQty,
                quoteAsset: m.quoteAsset,
                baseAsset: m.baseAsset
            }))
        };
    };
}
function BinanceSymbolsAllFuturesCoinM(data) {
    return async function () {
        const post = 'https://dapi.binance.com/dapi/v1/exchangeInfo';
        const result = await (await (data.fetch)(post))?.json();
        const symbols = result.symbols.filter((m) => (m.contractStatus == "TRADING") && (data?.quoteAsset ? m.quoteAsset == data.quoteAsset : true));
        return {
            symbols: symbols.map((m) => ({
                name: m.symbol,
                tickSize: m.filters?.[0]?.tickSize,
                minPrice: m.filters?.[1]?.tickSize,
                minStepLot: m.filters?.[0]?.tickSize,
                minQty: m.filters?.[2]?.minQty,
                stepSize: m.stepSize?.[2]?.minQty,
                quoteAsset: m.quoteAsset,
                baseAsset: m.baseAsset
            }))
        };
    };
}
function BinanceSocketRealTimeSpotNew(_WebSocket) {
    return function (info, callback, disable, onclose) {
        if (!info.name) {
            onclose();
            return;
        }
        const url = 'wss://stream.Binance.com:9443/ws/' + info.name.toLowerCase() + '@bookTicker';
        let lastPrice = 0;
        const socket = new _WebSocket(url);
        socket.onerror = (e) => { console.error('WebSocket Error: ', e, ' ', info.name); };
        socket.onclose = () => { onclose(); };
        socket.onmessage = (e) => {
            let data = JSON.parse(e.data);
            if (lastPrice == data.b)
                return;
            lastPrice = data.b;
            if (disable()) {
                socket.close();
            }
            return callback({
                ticks: [{ time: new Date(), price: Number(data.b), volume: 1 }]
            });
        };
    };
}
function BinanceSocketKlineAllBase(setting) {
    return function (callback, disable, onclose, data) {
        const combiner = "/stream?streams=" + (data.names.map(e => e.toLowerCase() + "@kline_1m")).join("/");
        const url = setting.url + combiner;
        const socket = new setting.WebSocket(url);
        socket.onerror = (e) => console.error('WebSocket Error: ', e, ' ');
        socket.onclose = () => { onclose(); };
        socket.onmessage = (e) => {
            const data = JSON.parse(e.data);
            const datum = data.data;
            const ar = {
                data: {
                    s: datum.s,
                    i: Time_1.TF.M1,
                    n: +datum.k.n,
                    V: +datum.k.V,
                    v: +datum.k.v,
                    t: +datum.k.t,
                    f: +datum.k.f,
                    h: +datum.k.h,
                    l: +datum.k.l,
                    o: +datum.k.o,
                    c: +datum.k.c,
                },
                name: datum.s
            };
            return callback(ar);
        };
    };
}
function BinanceSocketKlineSpotAllNew(_WebSocket) {
    return BinanceSocketKlineAllBase({ WebSocket: _WebSocket, url: 'wss://stream.binance.com:9443' });
}
function BinanceSocketKlineFAll(_WebSocket) {
    return BinanceSocketKlineAllBase({ WebSocket: _WebSocket, url: 'wss://fstream.binance.com:9443' });
}
function BinanceSocketKlineDAll(_WebSocket) {
    return BinanceSocketKlineAllBase({ WebSocket: _WebSocket, url: 'wss://dstream.binance.com:9443' });
}
function BinanceSocketSpotAllTurboNew(_WebSocket) {
    return function (callback, disable, onclose) {
        const url = 'wss://stream.Binance.com:9443/ws/!bookTicker';
        const socket = new _WebSocket(url);
        socket.onerror = (e) => console.error('WebSocket Error: ', e, ' ');
        socket.onclose = () => { onclose(); };
        socket.onmessage = (e) => {
            let data = JSON.parse(e.data);
            const ar = [
                {
                    data: {
                        ticks: [{ time: new Date(), price: +data.b, volume: 0 }]
                    },
                    name: data.s
                }
            ];
            return callback(ar);
        };
    };
}
function BinanceSocketAllBase(data) {
    const url = data.url ?? 'wss://stream.Binance.com:9443/ws/!ticker@arr';
    return function (callback, disable, onclose) {
        const socket = new data.WebSocket(url);
        socket.onerror = (e) => console.error('WebSocket Error: ', e, ' ');
        socket.onopen = (e) => { };
        socket.onclose = (e) => { onclose(); };
        socket.onmessage = (e) => {
            let data = JSON.parse(e.data);
            const ar = data.map((e) => {
                return {
                    data: {
                        ticks: [{ time: new Date(+e.E), price: +e.c, volume: 0 }]
                    },
                    name: e.s,
                    info: {
                        close24: +e.c,
                        open24: +e.o,
                        volumeBase24: +e.v,
                        volume24: +e.q
                    }
                };
            });
            return callback(ar);
        };
    };
}
function BinanceSocketSpotAllNew(WebSocket) {
    return BinanceSocketAllBase({
        WebSocket: WebSocket,
        url: 'wss://stream.binance.com:9443/ws/!ticker@arr'
    });
}
function BinanceSocketFuturesAll(WebSocket) {
    return BinanceSocketAllBase({
        WebSocket: WebSocket,
        url: 'wss://fstream.binance.com/ws/!ticker@arr'
    });
}
function BinanceSocketDCoinMAll(WebSocket) {
    return BinanceSocketAllBase({
        WebSocket: WebSocket,
        url: 'wss://dstream.binance.com/ws/!ticker@arr'
    });
}
const binanceFuncLoad = async ({ symbol, interval, startTime, endTime, limit, baseURL, fetch }) => {
    const _interval = `&interval=${interval}`;
    const _startTime = `&startTime=${startTime.valueOf()}`;
    const _endTime = endTime ? `&endTime=${endTime.valueOf()}` : ``;
    const _limit = endTime ? `&limit=${limit}` : ``;
    const url = baseURL + `symbol=${symbol}` + _interval + _startTime + _endTime + _limit;
    const data = (await (await fetch(url)).json());
    return data?.map((m) => ({
        time: new Date(+m[0]),
        open: +m[1],
        high: +m[2],
        low: +m[3],
        close: +m[4],
        volume: +m[5],
        tickVolume: +m[8]
    })) ?? [];
};
const binanceFuncFistTime = async ({ symbol, interval, baseURL, fetch }) => {
    const data = baseURL + `symbol=${symbol}` + `&interval=${interval}` + `&startTime=${String(new Date('2000').valueOf())}` + `&limit=1`;
    const parseData = (await (await fetch(data)).json());
    return new Date(Number(parseData?.[0]?.[0]));
};
const binanceInterval = [
    { time: Time_1.TF.M1, name: '1m' },
    { time: Time_1.TF.M3, name: '3m' },
    { time: Time_1.TF.M5, name: '5m' },
    { time: Time_1.TF.M15, name: '15m' },
    { time: Time_1.TF.M30, name: '30m' },
    { time: Time_1.TF.H1, name: '1h' },
    { time: Time_1.TF.H2, name: '2h' },
    { time: Time_1.TF.H4, name: '4h' },
    { time: Time_1.TF.H6, name: '6h' },
    { time: Time_1.TF.H8, name: '8h' },
    { time: Time_1.TF.H12, name: '12h' },
    { time: Time_1.TF.D1, name: '1d' },
    { time: Time_1.TF.W1, name: '1w' }
];
const BinanceLoadEasySpot = (data) => (0, LoadBase_1.LoadQuoteBase)({
    base: 'https://api1.binance.com/api/v3/klines?',
    maxLoadBars2: 1000,
    countConnect: 1150,
    maxLoadBars: 1000,
    time: 60000,
    funcLoad: binanceFuncLoad,
    funcFistTime: binanceFuncFistTime,
    intervalToName: binanceInterval
}, data);
exports.BinanceLoadEasySpot = BinanceLoadEasySpot;
const BinanceLoadEasyFutures = (data) => (0, LoadBase_1.LoadQuoteBase)({
    base: 'https://fapi.binance.com/fapi/v1/klines?',
    maxLoadBars2: 1000,
    countConnect: 450,
    maxLoadBars: 1000,
    time: 60000,
    funcLoad: binanceFuncLoad,
    funcFistTime: binanceFuncFistTime,
    intervalToName: binanceInterval
}, data);
exports.BinanceLoadEasyFutures = BinanceLoadEasyFutures;
const BinanceLoadEasyFuturesM = (data) => (0, LoadBase_1.LoadQuoteBase)({
    base: 'https://dapi.binance.com/dapi/v1/klines?',
    maxLoadBars2: 1000,
    countConnect: 450,
    maxLoadBars: 1000,
    time: 60000,
    funcLoad: binanceFuncLoad,
    funcFistTime: binanceFuncFistTime,
    intervalToName: binanceInterval
}, data);
exports.BinanceLoadEasyFuturesM = BinanceLoadEasyFuturesM;
const MexcLoadEasyFuturesM = (data) => (0, LoadBase_1.LoadQuoteBase)({
    base: 'https://api.mexc.com/api/v3/klines?',
    maxLoadBars2: 1000,
    countConnect: 1150,
    maxLoadBars: 1000,
    time: 60000,
    funcLoad: async ({ symbol, interval, startTime, endTime, limit, baseURL, fetch }) => {
        const _interval = `&interval=${interval}`;
        const _startTime = `&startTime=${startTime.valueOf()}`;
        const _endTime = endTime ? `&endTime=${endTime.valueOf()}` : ``;
        const _limit = endTime ? `&limit=${limit}` : ``;
        const url = baseURL + `symbol=${symbol}` + _interval + _startTime + _endTime + _limit;
        const data = (await (await fetch(url)).json());
        return data?.map((m) => ({
            time: new Date(+m[0]),
            open: +m[1],
            high: +m[2],
            low: +m[3],
            close: +m[4],
            volume: +m[5],
            tickVolume: +m[8]
        }));
    },
    funcFistTime: async (e) => new Date('2022'),
    intervalToName: binanceInterval
}, data);
exports.MexcLoadEasyFuturesM = MexcLoadEasyFuturesM;
const GateIoLoadEasySpot = (data) => (0, LoadBase_1.LoadQuoteBase)({
    base: 'https://api.gateio.ws/api/v4/spot/candlesticks?',
    maxLoadBars2: 500,
    countConnect: 500000,
    maxLoadBars: 500,
    time: 60000,
    funcLoad: async ({ symbol, interval, startTime, endTime, limit, baseURL, fetch }) => {
        const _interval = `&interval=${interval}`;
        const _startTime = `&startTime=${startTime.valueOf()}`;
        const _endTime = endTime ? `&endTime=${endTime.valueOf()}` : ``;
        const _limit = endTime ? `&limit=${limit}` : ``;
        const url = baseURL + `symbol=${symbol}` + _interval + _startTime + _endTime + _limit;
        const data = (await (await fetch(url)).json());
        return data?.map((m) => ({
            time: new Date(+m[0] * 1000),
            open: +m[5],
            high: +m[3],
            low: +m[4],
            close: +m[2],
            volume: +m[1],
            tickVolume: 0
        }));
    },
    funcFistTime: async ({ symbol, interval, baseURL, fetch }) => {
        const url = baseURL + `currency_pair=${symbol}` + '&interval=' + interval + '&from=' + String(Math.round(new Date('2022-01-15').valueOf() / 1000)) + '&to=' + String(Math.round((new Date('2022-01-15').valueOf() / 1000) + 60));
        const data = (await (await fetch(url)).json());
        const result = data?.[0]?.[0];
        return new Date(Number(result) * 1000);
    },
    intervalToName: binanceInterval
}, data);
exports.GateIoLoadEasySpot = GateIoLoadEasySpot;
const USALoadEasyFuturesM = (data) => (0, LoadBase_1.LoadQuoteBase)({
    base: 'http://localhost:3013/historyUSA/history?',
    maxLoadBars2: 10000,
    countConnect: 1,
    maxLoadBars: 10000,
    time: 300,
    funcLoad: async ({ symbol, interval, startTime, endTime: __endTime, limit, baseURL, fetch }) => {
        const maxBarTime = (Date.now() - 60 * 1000 * 16);
        const endTime = !__endTime || __endTime.valueOf() > maxBarTime ? new Date(maxBarTime) : __endTime;
        const _interval = `&tf=${interval}`;
        const _startTime = `&start=${startTime.toISOString()}`;
        const _endTime = endTime ? `&end=${endTime.toISOString()}` : ``;
        const _limit = endTime ? `&limit=${limit}` : ``;
        const url = baseURL + `symbol=${symbol}` + _interval + _startTime + _endTime + _limit;
        const data = (await (await fetch(url)).json())?.data;
        return data?.map(({ t, o, h, l, c, v, n, nw }) => {
            return ({
                time: new Date(t),
                open: +o,
                high: +h,
                low: +l,
                close: +c,
                volume: +v,
                tickVolume: +0
            });
        }) ?? [];
    },
    funcFistTime: async ({ symbol, interval, baseURL, fetch }) => {
        return new Date('2022');
    },
    intervalToName: [
        { time: Time_1.TF.M1, name: '1Min' },
        { time: Time_1.TF.M5, name: '5Min' },
        { time: Time_1.TF.M15, name: '15Min' },
        { time: Time_1.TF.M30, name: '30Min' },
        { time: Time_1.TF.H1, name: '1Hour' },
        { time: Time_1.TF.H4, name: '4Hour' }
    ]
}, data);
exports.USALoadEasyFuturesM = USALoadEasyFuturesM;
var Test;
(function (Test) {
    function Test1() { }
    Test.Test1 = Test1;
    function Test2() { }
})(Test || (exports.Test = Test = {}));
