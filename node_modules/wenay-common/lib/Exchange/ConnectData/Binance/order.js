"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.spaceBinance = void 0;
const commonOrder_1 = require("./commonOrder");
var spaceBinance;
(function (spaceBinance) {
    function NormalizePrice(value, priceStep) {
        if (priceStep < 1)
            return value.toFixed(-Math.log10(priceStep));
        else
            return value.toFixed(0);
    }
    const nLot = (data) => (0, commonOrder_1.NormalizeLot)(data.volume, data.minLot, data.stepLot).toFixed(6);
    const nPrice = (data) => NormalizePrice(data.price, data.stepPrice);
    function binanceSpot(binance) {
        return {
            async buy(data) { await binance.marketBuy(data.symbol, nLot(data)); },
            async sell(data) { await binance.marketSell(data.symbol, nLot(data)); },
            async buyLimit(data) { await binance.buy(data.symbol, nLot(data), nPrice(data), { type: 'LIMIT' }); },
            async sellLimit(data) { await binance.sell(data.symbol, nLot(data), nPrice(data), { type: 'LIMIT' }); },
            async cancelOrders(data) { await binance.cancel(data.symbol, data.orderId); },
            async getOrders() { }
        };
    }
    spaceBinance.binanceSpot = binanceSpot;
    function binanceFutures(binance) {
        return {
            async buy(data) { await binance.futuresMarketBuy(data.symbol, nLot(data), data.params ?? {}); },
            async sell(data) { await binance.marketSell(data.symbol, nLot(data), data.params ?? {}); },
            async buyLimit(data) { await binance.futuresBuy(data.symbol, nLot(data), nPrice(data)); },
            async sellLimit(data) { await binance.futuresSell(data.symbol, nLot(data), nPrice(data)); },
            async cancelOrders(data) { await binance.futuresCancel(data.symbol, { orderId: data.orderId }); },
            async getOrders() { }
        };
    }
    spaceBinance.binanceFutures = binanceFutures;
    function binanceIso(binance) {
        return {
            async buy(data) { await binance.mgMarketBuy(data.symbol, nLot(data), { type: 'MARKET' }); },
            async sell(data) { await binance.mgMarketSell(data.symbol, nLot(data), { type: 'MARKET' }); },
            async buyLimit(data) { await binance.mgBuy(data.symbol, nLot(data), nPrice(data), { type: 'LIMIT' }); },
            async sellLimit(data) { await binance.mgSell(data.symbol, nLot(data), nPrice(data), { type: 'LIMIT' }); },
            async cancelOrders(data) {
                await new Promise((resolve, reject) => {
                    binance.mgCancel(data.symbol, data.orderId, (error, response) => {
                        if (!error)
                            resolve(response);
                        else {
                            reject(error);
                        }
                    }, 'TRUE');
                });
            },
            async getOrders() { }
        };
    }
    spaceBinance.binanceIso = binanceIso;
    function transferMoneyF(binance) {
        return (data) => {
            const { from, to, amount } = data;
            const asset = data.asset ?? "USDT";
            return new Promise((resolve, reject) => {
                const result = (error) => !error ? resolve(true) : reject(error);
                if (from == "SPOT" && to == "MARGIN")
                    binance.mgTransferMainToMargin(asset, amount, result);
                if (from == "MARGIN" && to == "SPOT")
                    binance.mgTransferMarginToMain(asset, amount, result);
                if (from == "SPOT" && to == "FUTURES")
                    binance.transferMainToFutures(asset, amount, result);
                if (from == "FUTURES" && to == "SPOT")
                    binance.transferFuturesToMain(asset, amount, result);
            });
        };
    }
    spaceBinance.transferMoneyF = transferMoneyF;
    const binanceHeader = (apiKey) => ({ headers: { 'Content-type': 'application/x-www-form-urlencoded', 'X-MBX-APIKEY': apiKey } });
    class BinanceDataFunc {
        maxBorrowableCrossF({ axios, apiKey, apiSecret, GetSignatureFunc }) {
            return {
                wight: {
                    type: "IP",
                    wight: 50,
                    max: 10000,
                    timeMs: 60 * 1000
                },
                function: async function (asset) {
                    const timestamp = Date.now();
                    const signature = GetSignatureFunc({ asset, timestamp }, apiSecret);
                    const url = `https://api.binance.com/sapi/v1/margin/maxBorrowable?asset=${asset}&timestamp=${timestamp}&signature=${signature}`;
                    const res = await axios.get(url, { ...binanceHeader(apiKey) }).catch(e => {
                        console.log(e);
                        throw e;
                    });
                    return {
                        amount: +res.data.amount,
                        borrowLimit: +res.data.borrowLimit
                    };
                }
            };
        }
        maxBorrowableIsolatedF({ axios, apiKey, apiSecret, GetSignatureFunc }) {
            return {
                wight: {
                    type: "IP",
                    wight: 50,
                    max: 10000,
                    timeMs: 60 * 1000
                },
                function: async function (asset, isolatedSymbol) {
                    const timestamp = Date.now();
                    const signature = GetSignatureFunc({ asset, timestamp }, apiSecret);
                    const url = `https://api.binance.com/sapi/v1/margin/maxBorrowable?asset=${asset}&timestamp=${timestamp}&isolatedSymbol=${isolatedSymbol}&signature=${signature}`;
                    const res = await axios.get(url, { ...binanceHeader(apiKey) }).catch(e => {
                        console.log(e);
                        throw e;
                    });
                    return {
                        amount: +res.data.amount,
                        borrowLimit: +res.data.borrowLimit
                    };
                }
            };
        }
        maxTransferableCrossF({ axios, apiKey, apiSecret, GetSignatureFunc }) {
            return {
                wight: {
                    type: "IP",
                    wight: 50,
                    max: 10000,
                    timeMs: 60 * 1000
                },
                function: async function (asset, isolatedSymbol) {
                    const timestamp = Date.now();
                    const signature = GetSignatureFunc({ asset, timestamp }, apiSecret);
                    const url = `https://api.binance.com/sapi/v1/margin/maxTransferable?asset=${asset}&timestamp=${timestamp}&signature=${signature}`;
                    const res = await axios.get(url, { ...binanceHeader(apiKey) }).catch(e => {
                        console.log(e);
                        throw e;
                    });
                    return {
                        amount: +res.data.amount
                    };
                }
            };
        }
        maxTransferableIsolatedF({ axios, apiKey, apiSecret, GetSignatureFunc }) {
            return {
                wight: {
                    type: "IP",
                    wight: 50,
                    max: 10000,
                    timeMs: 60 * 1000
                },
                function: async function (asset, isolatedSymbol) {
                    const timestamp = Date.now();
                    const signature = GetSignatureFunc({ asset, timestamp }, apiSecret);
                    const url = `https://api.binance.com/sapi/v1/margin/maxTransferable?asset=${asset}&timestamp=${timestamp}&isolatedSymbol=${isolatedSymbol}&signature=${signature}`;
                    const res = await axios.get(url, { ...binanceHeader(apiKey) }).catch(e => {
                        console.log(e);
                        throw e;
                    });
                    return {
                        amount: +res.data.amount
                    };
                }
            };
        }
        transferIsolatedF({ axios, apiKey, apiSecret, GetSignatureFunc }) {
            return {
                wight: {
                    type: "IP",
                    wight: 50,
                    max: 10000,
                    timeMs: 60 * 1000
                },
                function: async function (asset, symbol, amount, fromAccountType) {
                    const timestamp = Date.now();
                    const type = fromAccountType == "ISOLATED_MARGIN" ? 'ISOLATEDMARGIN_MARGIN' : 'MARGIN_ISOLATEDMARGIN';
                    const signature = fromAccountType == "ISOLATED_MARGIN" ? GetSignatureFunc({ type, asset, amount, fromSymbol: symbol, timestamp }, apiSecret) : GetSignatureFunc({ type, asset, amount, toSymbol: symbol, timestamp }, apiSecret);
                    const url = fromAccountType == "ISOLATED_MARGIN" ? `https://api.binance.com/sapi/v1/asset/transfer?type=${type}&asset=${asset}&amount=${amount}&fromSymbol=${symbol}&timestamp=${timestamp}&signature=${signature}` :
                        `https://api.binance.com/sapi/v1/asset/transfer?type=${type}&asset=${asset}&amount=${amount}&toSymbol=${symbol}&timestamp=${timestamp}&signature=${signature}`;
                    const res = await axios.post(url, '', { ...binanceHeader(apiKey) }).catch(e => {
                        console.log(e);
                        throw e;
                    });
                    return { tranId: +res.data.tranId };
                }
            };
        }
        transferIsolatedToSpotF({ axios, apiKey, apiSecret, GetSignatureFunc }) {
            return {
                wight: {
                    type: "UID",
                    wight: 600,
                    max: 150000,
                    timeMs: 60 * 1000
                },
                function: async function (asset, symbol, amount, transFrom) {
                    const timestamp = Date.now();
                    const transTo = transFrom == 'ISOLATED_MARGIN' ? 'SPOT' : 'ISOLATED_MARGIN';
                    const signature = GetSignatureFunc({ asset, symbol, transFrom, transTo, amount, timestamp }, apiSecret);
                    const url = `https://api.binance.com/sapi/v1/margin/isolated/transfer?asset=${asset}&symbol=${symbol}&transFrom=${transFrom}&transTo=${transTo}&amount=${amount}&timestamp=${timestamp}&signature=${signature}`;
                    const res = await axios.post(url, '', { ...binanceHeader(apiKey) }).catch(e => {
                        console.log(e);
                        throw e;
                    });
                    return { tranId: +res.data.tranId };
                }
            };
        }
        updateIsolatedAccsInfoÐF({ axios, apiKey, apiSecret, GetSignatureFunc }) {
            return {
                wight: {
                    type: "UID",
                    wight: 600,
                    max: 150000,
                    timeMs: 60 * 1000
                },
                function: async function (asset, symbol, amount, transFrom) {
                    const timestamp = Date.now();
                    const transTo = transFrom == 'ISOLATED_MARGIN' ? 'SPOT' : 'ISOLATED_MARGIN';
                    const signature = GetSignatureFunc({ asset, symbol, transFrom, transTo, amount, timestamp }, apiSecret);
                    const url = `https://api.binance.com/sapi/v1/margin/isolated/account?timestamp=${timestamp}&signature=${signature}`;
                    const res = await axios.get(url, { ...binanceHeader(apiKey) }).catch(e => {
                        console.log(e);
                        throw e;
                    });
                    const result = {
                        assets: res?.data?.assets,
                        totalAssetOfBtc: res.data.totalAssetOfBtc && +res.data.totalAssetOfBtc
                    };
                    return result;
                }
            };
        }
        disableIsolatedAccF({ axios, apiKey, apiSecret, GetSignatureFunc }) {
            return {
                wight: {
                    type: "UID",
                    wight: 300,
                    max: 150000,
                    timeMs: 60 * 1000
                },
                function: async function (symbol) {
                    const timestamp = Date.now();
                    const signature = GetSignatureFunc({ symbol, timestamp }, apiSecret);
                    const url = `https://api.binance.com/sapi/v1/margin/isolated/account?symbol=${symbol}&timestamp=${timestamp}&signature=${signature}`;
                    const res = await axios.delete(url, { ...binanceHeader(apiKey) }).catch(e => {
                        console.log(e);
                        throw e;
                    });
                    if (res?.data.success)
                        return true;
                    throw res?.data?.code;
                }
            };
        }
        enableIsolatedAccF({ axios, apiKey, apiSecret, GetSignatureFunc }) {
            return {
                wight: {
                    type: "UID",
                    wight: 300,
                    max: 150000,
                    timeMs: 60 * 1000
                },
                function: async function (symbol) {
                    const timestamp = Date.now();
                    const signature = GetSignatureFunc({ symbol, timestamp }, apiSecret);
                    const url = `https://api.binance.com/sapi/v1/margin/isolated/account?symbol=${symbol}&timestamp=${timestamp}&signature=${signature}`;
                    const res = await axios.post(url, '', { ...binanceHeader(apiKey) }).catch(e => {
                        console.log(e);
                        throw e;
                    });
                    if (res?.data.success)
                        return true;
                    throw res?.data?.code;
                }
            };
        }
        getIsolatedAccountsLimitF({ axios, apiKey, apiSecret, GetSignatureFunc }) {
            return {
                wight: {
                    type: "UID",
                    wight: 300,
                    max: 150000,
                    timeMs: 60 * 1000
                },
                function: async function (symbol) {
                    const timestamp = Date.now();
                    const signature = GetSignatureFunc({ symbol, timestamp }, apiSecret);
                    const url = `https://api.binance.com/sapi/v1/margin/isolated/accountLimit?timestamp=${timestamp}&signature=${signature}`;
                    const res = await axios.get(url, { ...binanceHeader(apiKey) }).catch(e => {
                        console.log(e);
                        throw e;
                    });
                    if (res?.data != undefined)
                        return res.data;
                    throw res?.data?.code;
                }
            };
        }
        getIsolationFeeDataF({ axios, apiKey, apiSecret, GetSignatureFunc }) {
            return {
                wight: {
                    type: "UID",
                    wight: 300,
                    max: 150000,
                    timeMs: 60 * 1000
                },
                function: async function (symbol) {
                    const timestamp = Date.now();
                    const signature = GetSignatureFunc({ symbol, timestamp }, apiSecret);
                    const url = `https://api.binance.com/sapi/v1/margin/isolatedMarginData?timestamp=${timestamp}&signature=${signature}`;
                    const res = await axios.get(url, { ...binanceHeader(apiKey) }).catch(e => {
                        console.log(e);
                        throw e;
                    });
                    if (res?.data != undefined)
                        return res.data;
                    throw res?.data?.code;
                }
            };
        }
        getIsolationFeeDataBySymbolF({ axios, apiKey, apiSecret, GetSignatureFunc }) {
            return {
                wight: {
                    type: "UID",
                    wight: 300,
                    max: 150000,
                    timeMs: 60 * 1000
                },
                function: async function (symbol) {
                    const timestamp = Date.now();
                    const signature = GetSignatureFunc({ symbol, timestamp }, apiSecret);
                    const url = `https://api.binance.com/sapi/v1/margin/isolatedMarginData?symbol=${symbol}&timestamp=${timestamp}&signature=${signature}`;
                    const res = await axios.get(url, { ...binanceHeader(apiKey) }).catch(e => {
                        console.log(e);
                        throw e;
                    });
                    if (res.data.length)
                        return res.data[0];
                    throw res?.data?.code;
                }
            };
        }
        getAllCrossMarginPairs({ axios, apiKey, apiSecret, GetSignatureFunc }) {
            return {
                wight: {
                    type: "IP",
                    wight: 1,
                    max: 10000,
                    timeMs: 60 * 1000
                },
                function: async function () {
                    const timestamp = Date.now();
                    const signature = GetSignatureFunc({ timestamp }, apiSecret);
                    const url = `https://api.binance.com/sapi/v1/margin/allPairs?timestamp=${timestamp}&signature=${signature}`;
                    const res = await axios.get(url, { ...binanceHeader(apiKey) }).catch(e => {
                        console.log(e);
                        throw e;
                    });
                    if (res?.data != undefined)
                        return res.data;
                    throw res?.data?.code;
                }
            };
        }
        getAllCrossIsolatePairs({ axios, apiKey, apiSecret, GetSignatureFunc }) {
            return {
                wight: {
                    type: "IP",
                    wight: 1,
                    max: 10000,
                    timeMs: 60 * 1000
                },
                function: async function () {
                    const timestamp = Date.now();
                    const signature = GetSignatureFunc({ timestamp }, apiSecret);
                    const url = `https://api.binance.com/sapi/v1/margin/isolated/allPairs?timestamp=${timestamp}&signature=${signature}`;
                    const res = await axios.get(url, { ...binanceHeader(apiKey) }).catch(e => {
                        console.log(e);
                        throw e;
                    });
                    if (res?.data != undefined)
                        return res.data;
                    throw res?.data?.code;
                }
            };
        }
        crossMarginAccountDetails({ axios, apiKey, apiSecret, GetSignatureFunc }) {
            return {
                wight: {
                    type: "IP",
                    wight: 10,
                    max: 10000,
                    timeMs: 60 * 1000
                },
                function: async function () {
                    const timestamp = Date.now();
                    const signature = GetSignatureFunc({ timestamp }, apiSecret);
                    const url = `https://api.binance.com/sapi/v1/margin/account?timestamp=${timestamp}&signature=${signature}`;
                    const res = await axios.get(url, { ...binanceHeader(apiKey) }).catch(e => {
                        console.log(e);
                        throw e;
                    });
                    if (res?.data != undefined)
                        return res.data;
                    throw res?.data?.code;
                }
            };
        }
    }
    spaceBinance.BinanceDataFunc = BinanceDataFunc;
    spaceBinance.binanceFunc = new BinanceDataFunc;
})(spaceBinance || (exports.spaceBinance = spaceBinance = {}));
