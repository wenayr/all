"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRpc = createRpc;
function createRpc(opts) {
    const { socket, channel, obj, limit, debug } = opts;
    const pendingMap = new Map();
    const callbacksMap = new Map();
    const free = (() => {
        const freeNums = [];
        let total = 0;
        let poz = 0;
        return {
            next() {
                return poz > 0 ? freeNums[--poz] : ++total;
            },
            freeId(id) {
                freeNums[poz++] = id;
            }
        };
    })();
    let strictlyObj = {};
    function ser(value, cbs) {
        if (typeof value === 'function') {
            const id = free.next();
            callbacksMap.set(id, value);
            cbs.push(id);
            return { ___FUNC: id };
        }
        if (!value || typeof value !== 'object') {
            return value;
        }
        if (Array.isArray(value)) {
            return value.map((v) => ser(v, cbs));
        }
        const copy = {};
        for (const k of Object.keys(value)) {
            const v = value[k];
            if (typeof v === 'function') {
                const id = free.next();
                callbacksMap.set(id, v);
                cbs.push(id);
                copy[k] = { ___FUNC: id };
            }
            else {
                copy[k] = ser(v, cbs);
            }
        }
        return copy;
    }
    function deser(value) {
        if (!value || typeof value !== 'object') {
            return value;
        }
        if (Array.isArray(value)) {
            return value.map((v) => deser(v));
        }
        if (value.___FUNC !== undefined) {
            const cbId = value.___FUNC;
            const fn = (...args) => {
                const pack = {
                    mapId: cbId,
                    data: ser(args, []),
                };
                socket.emit(channel, pack);
            };
            return fn;
        }
        const copy = {};
        for (const k of Object.keys(value)) {
            copy[k] = deser(value[k]);
        }
        return copy;
    }
    function sendPacket(data, wait = true, extraCallbacks) {
        return new Promise((resolve, reject) => {
            const mapId = free.next();
            const cbs = [];
            const payload = {
                mapId,
                data: ser(data, cbs),
                wait
            };
            if (extraCallbacks && extraCallbacks.length) {
                payload.callbacksId = [];
                for (const fn of extraCallbacks) {
                    const id = free.next();
                    callbacksMap.set(id, fn);
                    payload.callbacksId.push(id);
                }
            }
            if (cbs.length) {
                payload.callbacksId = (payload.callbacksId || []).concat(cbs);
            }
            if (wait) {
                pendingMap.set(mapId, { resolve, reject });
            }
            if (debug)
                console.log(`[sendPacket] -> ${channel}`, payload);
            socket.emit(channel, payload);
            if (!wait)
                resolve(undefined);
            if (limit && pendingMap.size > limit) {
                console.warn(`Pending promises exceed limit=${limit}`);
            }
        });
    }
    function createRootProxy() {
        return new Proxy({}, {
            get(_target, prop) {
                return createNestedProxy([String(prop)]);
            }
        });
    }
    function createNestedProxy(path) {
        return new Proxy(() => { }, {
            get(_fnTarget, prop) {
                if (!checkStrictly(path, prop)) {
                    return undefined;
                }
                return createNestedProxy([...path, String(prop)]);
            },
            apply(_fn, _thisArg, argArray) {
                if (!checkStrictly(path)) {
                    return Promise.reject(new Error(`Method ${path.join('.')} not accessible`));
                }
                const callbackFns = [];
                argArray.forEach((arg, i) => {
                    if (typeof arg === 'function') {
                        callbackFns.push(arg);
                        argArray[i] = '___FUNC';
                    }
                });
                return sendPacket({ key: path, request: argArray }, true, callbackFns);
            }
        });
    }
    function checkStrictly(path, prop) {
        if (!strictlyObj || Object.keys(strictlyObj).length === 0) {
            return true;
        }
        let cur = strictlyObj;
        for (let i = 0; i < path.length; i++) {
            const p = path[i];
            if (cur[p] === undefined || cur[p] === 'null') {
                return false;
            }
            cur = cur[p];
        }
        if (prop !== undefined) {
            if (cur[prop] === undefined || cur[prop] === 'null') {
                return false;
            }
        }
        return true;
    }
    const clientProxy = createRootProxy();
    function initServer() {
        socket.on(channel, async (pkt) => {
            if (debug)
                console.log(`[onMessage] <- ${channel}`, pkt);
            const { mapId, data, error, callbacksId, wait, STRICTLY } = pkt;
            if (pendingMap.has(mapId)) {
                const pr = pendingMap.get(mapId);
                pendingMap.delete(mapId);
                free.freeId(mapId);
                if (error) {
                    pr.reject(error);
                }
                else {
                    pr.resolve(deser(data));
                }
                return;
            }
            if (callbacksMap.has(mapId)) {
                const fn = callbacksMap.get(mapId);
                const args = deser(data) || [];
                try {
                    fn(...args);
                }
                catch (err) {
                    if (debug)
                        console.error(`[callback error]`, err);
                }
                return;
            }
            if (data === '___STRICTLY') {
                const sObj = reflectObj(obj);
                const response = {
                    mapId,
                    STRICTLY: sObj,
                };
                if (debug)
                    console.log(`[send STRICTLY] -> ${channel}`, response);
                socket.emit(channel, response);
                return;
            }
            if (!data)
                return;
            const keys = data.key || [];
            const args = deser(data.request) || [];
            if (callbacksId) {
            }
            let current = obj;
            let methodName = undefined;
            try {
                for (const k of keys) {
                    if (typeof current[k] === 'function') {
                        methodName = k;
                        break;
                    }
                    current = current[k];
                }
            }
            catch (err) {
                sendErr(mapId, err);
                return;
            }
            if (!methodName) {
                sendErr(mapId, `Not a function. Path: ${keys.join('.')}`);
                return;
            }
            const method = current[methodName];
            if (typeof method !== 'function') {
                sendErr(mapId, `Not a function: ${methodName}`);
                return;
            }
            try {
                const result = await method.apply(current, args);
                if (wait !== false) {
                    sendRes(mapId, result);
                }
            }
            catch (err) {
                sendErr(mapId, err);
            }
        });
    }
    function sendRes(mapId, data) {
        const packet = {
            mapId,
            data: ser(data, [])
        };
        if (debug)
            console.log(`[sendRes] -> ${channel}`, packet);
        socket.emit(channel, packet);
    }
    function sendErr(mapId, err) {
        const packet = {
            mapId,
            error: { err }
        };
        if (debug)
            console.log(`[sendErr] -> ${channel}`, packet);
        socket.emit(channel, packet);
    }
    async function strictlyInit() {
        const mapId = free.next();
        const p = new Promise((resolve) => {
            pendingMap.set(mapId, {
                resolve: () => resolve(),
                reject: () => resolve()
            });
        });
        const packet = {
            mapId,
            data: '___STRICTLY',
        };
        if (debug)
            console.log(`[strictlyInit] -> ${channel}`, packet);
        socket.emit(channel, packet);
        await p;
    }
    socket.on(channel, (pkt) => {
        if (pkt.STRICTLY) {
            if (debug)
                console.log(`[strictlyObj updated]`, pkt.STRICTLY);
            strictlyObj = {};
            Object.assign(strictlyObj, pkt.STRICTLY);
            if (pendingMap.has(pkt.mapId)) {
                const pr = pendingMap.get(pkt.mapId);
                pendingMap.delete(pkt.mapId);
                free.freeId(pkt.mapId);
                pr.resolve(undefined);
            }
        }
    });
    function infoStrictly() {
        return strictlyObj;
    }
    function reflectObj(o) {
        if (!o || typeof o !== 'object')
            return 'null';
        if (Array.isArray(o)) {
            return o.map((el) => reflectObj(el));
        }
        const out = {};
        for (const k of Object.keys(o)) {
            const val = o[k];
            if (typeof val === 'function') {
                out[k] = 'func';
            }
            else if (val && typeof val === 'object') {
                out[k] = reflectObj(val);
            }
            else {
                out[k] = 'null';
            }
        }
        return out;
    }
    return {
        client: clientProxy,
        initServer,
        strictlyInit,
        infoStrictly
    };
}
