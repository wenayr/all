"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.enhancedWaitRun = enhancedWaitRun;
exports.enhancedQueueRun = enhancedQueueRun;
exports.waitRun = waitRun;
exports.queueRun = queueRun;
const common_1 = require("./common");
function enhancedWaitRun() {
    let lastExecutionTime = 0;
    let activePromise = Promise.resolve();
    let isBusy = false;
    let latestFunction;
    return {
        throttleAsync: (ms, func) => {
            if (lastExecutionTime + ms < Date.now() && !isBusy) {
                isBusy = true;
                activePromise = activePromise.then(() => {
                    try {
                        return func();
                    }
                    catch (error) {
                        console.error("Error in throttleAsync function:", error);
                    }
                    finally {
                        isBusy = false;
                        lastExecutionTime = Date.now();
                    }
                });
            }
        },
        debounceAsync: (ms, func) => {
            if (!func)
                throw new Error("debounceAsync: func is undefined");
            latestFunction = func;
            if (!isBusy) {
                isBusy = true;
                activePromise = activePromise.finally(async () => {
                    try {
                        await (0, common_1.sleepAsync)(ms);
                        await latestFunction?.();
                    }
                    catch (error) {
                        console.error("Error in debounceAsync function:", error);
                    }
                    finally {
                        isBusy = false;
                        activePromise = Promise.resolve();
                    }
                });
            }
            return activePromise;
        },
    };
}
function enhancedQueueRun(maxParallelTasks = 5) {
    const taskQueue = [];
    const workers = Array(maxParallelTasks).fill(Promise.resolve());
    const processNextTask = () => {
        const task = taskQueue.shift();
        if (task) {
            return task()
                .catch((error) => {
                console.error("Error in task execution:", error);
            })
                .finally(processNextTask);
        }
    };
    const checkAndRun = () => {
        workers.forEach((worker, index) => {
            if (!worker || worker === Promise.resolve()) {
                workers[index] = processNextTask() || Promise.resolve();
            }
        });
    };
    return {
        get queueSize() {
            return taskQueue.length;
        },
        enqueue(task) {
            taskQueue.push(task);
        },
        enqueueAndRun(task) {
            taskQueue.push(task);
            checkAndRun();
        },
        runAll() {
            checkAndRun();
            return Promise.allSettled(workers);
        },
    };
}
function waitRun() {
    const enhancedFunctions = enhancedWaitRun();
    return {
        refreshAsync: enhancedFunctions.throttleAsync,
        refreshAsync2: enhancedFunctions.debounceAsync,
    };
}
function queueRun(n = 5) {
    const enhancedQueue = enhancedQueueRun(n);
    return {
        get size() {
            return enhancedQueue.queueSize;
        },
        set next(task) {
            enhancedQueue.enqueue(task);
        },
        set nextRun(task) {
            enhancedQueue.enqueueAndRun(task);
        },
        run: () => enhancedQueue.runAll(),
    };
}
