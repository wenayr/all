"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.enhancedWaitRun = enhancedWaitRun;
exports.createAsyncQueue = createAsyncQueue;
exports.enhancedQueueRun = enhancedQueueRun;
exports.waitRun = waitRun;
exports.queueRun = queueRun;
exports.createTaskQueue = createTaskQueue;
const common_1 = require("./common");
function enhancedWaitRun() {
    let lastExecutionTime = 0;
    let activePromise = Promise.resolve();
    let isBusy = false;
    let latestFunction;
    return {
        throttleAsync: (ms, func) => {
            if (lastExecutionTime + ms < Date.now() && !isBusy) {
                isBusy = true;
                activePromise = activePromise.then(() => {
                    try {
                        return func();
                    }
                    catch (error) {
                        console.error("Error in throttleAsync function:", error);
                    }
                    finally {
                        isBusy = false;
                        lastExecutionTime = Date.now();
                    }
                });
            }
        },
        debounceAsync: (ms, func) => {
            if (!func)
                throw new Error("debounceAsync: func is undefined");
            latestFunction = func;
            if (!isBusy) {
                isBusy = true;
                activePromise = activePromise.finally(async () => {
                    try {
                        await (0, common_1.sleepAsync)(ms);
                        await latestFunction?.();
                    }
                    catch (error) {
                        console.error("Error in debounceAsync function:", error);
                    }
                    finally {
                        isBusy = false;
                        activePromise = Promise.resolve();
                    }
                });
            }
            return activePromise;
        },
    };
}
function createAsyncQueue(concurrency = 1) {
    let queue = [];
    let activeCount = 0;
    let resolveIdle = null;
    let idlePromise = null;
    const runNext = () => {
        if (activeCount >= concurrency || queue.length === 0) {
            if (activeCount === 0 && queue.length === 0 && resolveIdle) {
                resolveIdle();
                resolveIdle = null;
                idlePromise = null;
            }
            return;
        }
        const task = queue.shift();
        if (!task)
            return;
        activeCount++;
        task().finally(() => {
            activeCount--;
            runNext();
        });
        runNext();
    };
    const enqueue = (task) => {
        return new Promise((resolve, reject) => {
            queue.push(async () => {
                try {
                    resolve(await task());
                }
                catch (err) {
                    reject(err);
                }
            });
            runNext();
        });
    };
    const onIdle = () => {
        if (!idlePromise) {
            idlePromise = new Promise((resolve) => {
                if (activeCount === 0 && queue.length === 0) {
                    resolve();
                }
                else {
                    resolveIdle = resolve;
                }
            });
        }
        return idlePromise;
    };
    const getQueueSize = () => queue.length;
    return {
        enqueue,
        onIdle,
        getQueueSize,
    };
}
function enhancedQueueRun(maxParallelTasks = 5) {
    const tr = createAsyncQueue(maxParallelTasks);
    return {
        get queueSize() {
            return tr.getQueueSize();
        },
        enqueue(task) {
            tr.enqueue(task);
        },
        enqueueAndRun(task) {
            tr.enqueue(task);
        },
        runAll() {
            return tr.onIdle();
        },
    };
}
function waitRun() {
    const enhancedFunctions = enhancedWaitRun();
    return {
        refreshAsync: enhancedFunctions.throttleAsync,
        refreshAsync2: enhancedFunctions.debounceAsync,
    };
}
function queueRun(n = 5) {
    const enhancedQueue = enhancedQueueRun(n);
    return {
        get size() {
            return enhancedQueue.queueSize;
        },
        set next(task) {
            enhancedQueue.enqueue(task);
        },
        set nextRun(task) {
            enhancedQueue.enqueueAndRun(task);
        },
        run: () => enhancedQueue.runAll(),
    };
}
function createTaskQueue() {
    let ready = false;
    const tasks = [];
    return {
        add: (fn) => ready ? void fn() : tasks.push(fn),
        setReady: async () => {
            ready = true;
            for (const fn of tasks)
                await fn();
            tasks.length = 0;
        },
        isReady: () => ready,
        tasks: () => [...tasks],
    };
}
;
