export type tSocket = {
    emit: (channel: string, msg: any) => void;
    on: (channel: string, callback: (msg: any) => void) => void;
};
interface tRpcOptions<T extends object> {
    socket: tSocket;
    channel: string;
    obj: T;
    limit?: number;
    debug?: boolean;
}
type TProxy<T> = {
    [K in keyof T]: T[K] extends (...args: infer A) => infer R ? (...args: A) => Promise<UnwrapPromise<R>> : T[K] extends object ? TProxy<T[K]> : Promise<T[K]>;
};
type UnwrapPromise<T> = T extends Promise<infer R> ? R : T;
interface tRpcAPI<T extends object> {
    client: TProxy<T>;
    initServer: () => void;
    strictlyInit: () => Promise<void>;
    infoStrictly: () => any;
}
export declare function createRpc<T extends object>(opts: tRpcOptions<T>): tRpcAPI<T>;
export {};
